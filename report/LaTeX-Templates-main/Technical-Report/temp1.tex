\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{mathrsfs}
\usepackage{yfonts}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }
\begin{document}
\section{Method}

The server \textit{ticks} every \(0.1\) seconds, wherewithin one command can be sent from each of the players and from the trainer. The program runs a loop in the background which sends a command from the trainer to the server continually (at each tick), requesting information about the state of the field \(S_i \in \mathcal{S}\) at that time step \(i \in \mathbb{N}\). The field state is constituted by the position and velocity vector of the ball and the positions, velocity vectors and rotations of all the players.

The teams are represented as set \(\mathcal{T} := \left\{ T_A, T_B \right\}\), where \(T_A = (\text{``Team\_A''}, P_{T_A})\) and \(T_B = (\text{``Team\_B''}, P_{T_B})\). \(P_T : \mathcal{I} \to \mathcal{P} \) is a function mapping a \textit{player number} \(i\in \mathcal{I} := \{1,\cdots,6\}\) to each player \(p \in \mathcal{P}\) in a given team. A player \(p\in \mathcal{P}\) is a vector \((\phi, c, f)\) where \(\phi = (x, y, \theta) \in \mathbb{R}^3\) describes the position and angle of the player; \(c \in \mathcal{C} := \mathbb{N}^6\) is a vector representing the \textit{task configuration} for that player; \(\mathcal{A} \ni f:\mathcal{S}\times \mathcal{C} \to \mathcal{S}\) is the the player's given task from a set of possible tasks \(\mathcal{A}\), all of which return within one tick.%; \(s \in \{\top,\bot\}\) represents the \textit{status} of \(f\), where \(\top\) means "the task is completed" and \(\bot\) means "the task is ongoing".

At each time step \(i\), a background process executes each player's task
%\(F := \bigcup_{(T,i)\in\mathcal{T} \times \mathcal{I}} \pi_f(P_T(i)) \), \(F := \left\{ f_c:\mathcal{S}\to\mathcal{S} \,\middle|\, f_c = \lambda c.f\ \pi_c(P_T(i)), (f', c') \in \bigcup_{(T,i)\in\mathcal{T} \times \mathcal{I}} ( \pi_f(P_T(i)), \pi_c(P_T(i))) \right\}\), \(F := \bigcup_{(T,i)\in\mathcal{T} \times \mathcal{I}} \lambda s.\pi_f(P_T(i))(s, \pi_c(P_T(i))) \), 
\[
		F := \left\{ f_c \,\middle|\, f_c = \lambda s.f(s, c), f = \pi_f(p), c = \pi_c(p), p = P_T(i), (T,i)\in\mathcal{T} \times \mathcal{I}  \right\}
\text{,}
\]
which sends commands from those players to the server, resulting in the next state 
\[
		\mathcal{S} \ni S_{i} = \left\{
			\begin{array}{cl}
				S_0 & : \ i = 0 \\
					\mathfrak{U} \left( \left(\underset{f_c\in F}\bigcirc f_c\right)(S_{i-1}) \right) & : \ \text{otherwise}
			\end{array}
		\right.
\]
where \(S_0\) is the initial configuration of the game field and \(\mathfrak{U}\) is an unknown function representing collision handling and other unknown or random behaviours from the server simulation and program-server interface. %RANDOMNESS MAKES THE SOLUTION-FINDING MODELING HARDER -- STATISTICS AND SUCH

[ADD INFO ABOUT STRUCTURE OF BT/f AND THE DERIVATION THEREOF]
%The structure of the behaviour tree is generated by the following logic: \(\text{Kick ball} \Rightarrow \text{Close to ball} \Rightarrow \text{Go to ball}\), \(\mathscr{K} \subseteq \mathscr{C}\)

Låt gruppen \(G\) vara genererad av avbildningarna i \(\mathfrak{A}\) sammansättningsvis, där varje avbildning representerar en handling som aktören kan utföra på världen.
\begin{equation}
		G:=\left(\langle\mathfrak{A}\rangle,\circ\right)
\end{equation}
%Låt avbildningsmängden \(\mathscr{S}_x\) vara samtliga avbildningssammansättningar som ekvivalerar en avbildning \(x\in G\), med andra ord samtliga \textit{lösningar} till \(x\) givet handlingsmänden \(\mathfrak{A}\).
Låt mängden \(\mathscr{S}_x\) vara samtliga avbildningssammansättningar som ekvivalerar en avbildning \(x\in G\) -- d.v.s. samtliga \textit{lösningar} till \(x\) givet handlingsmänden \(\mathfrak{A}\).

THE BEHAVIOUR TREE GENERATES THE FOLLOWING SET
\begin{equation}
%		\mathscr{S}_x = \left\{ (f_1,...,f_n) \in \mathfrak{A}^n \,\middle|\, x\in G\wedge\overset{1}{\underset{i=n}\bigcirc} f_i = x \right\}
		\mathscr{S}_x = \left\{ s \in \bigcup_{n\in \mathbb{N}}\mathfrak{A}^n \,\middle|\, x\in G\wedge\overset{1}{\underset{i=|s|}\bigcirc} s_i = x \right\}
\end{equation}
Avbildningsmängden \(\mathscr{F}_x\) definieras som samtliga \textit{kortaste} lösningar till \(x\).

THE GENETIC ALGORITHM TRIES TO APPROXIMATE THE FOLLOWING SET \begin{equation}
		\mathscr{F}_x=\left\{s\in\mathscr{S}_x \,\middle|\, s'\in \mathscr{S}_x \Rightarrow |s|\le|s'|\right\}
\end{equation}

[ADD INFO ABOUT GA]

\end{document}
