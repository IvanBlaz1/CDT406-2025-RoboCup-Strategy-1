\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{mathrsfs}
\usepackage{yfonts}
\usepackage{tikz}
\usepackage{forest}
\usetikzlibrary{trees}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }
\begin{document}
\section{Method}

\subsection{Introduction}
The server \textit{ticks} every \(0.1\) seconds, wherewithin one command can be sent from each of the players and from the trainer. The program runs a loop in the background which sends a command from the trainer to the server continually (at each tick), requesting information about the state of the field at that time step. A state \(S_i \in \mathcal{S}\) where \(i \in \mathbb{N}\) contains the actual field state as well as the (possibly delayed) information thereabout which is known by the actors. Field-state information include the position and velocity of the ball as well as the speed, velocity and orientation of the players.

The players are represented as a set \(\mathcal{P}=\left\{p_1,\cdots,p_{12}\right\}\). A player \(p \in \mathcal{P}\) is a pair \((c, f)\) where \(c \in \mathcal{C} := \mathbb{N}^6\) is a vector representing the \textit{skill configuration} for that player and \(f : \mathcal{S}\times \mathcal{C} \to \mathcal{S}\) is the the \textit{de facto} effect on the field state of an assigned task \(\mathfrak{a}\in\mathfrak{A}\), all of which return within one tick.

At each time step \(i\), a background process executes each player's ``configured'' task
\[
		F := \left\{ f_p^c \,\middle|\, f_p^c = \lambda s.f_p(s, c), f_p = \pi_f(p), c = \pi_c(p), p \in\mathcal{P} \right\}
\]
which sends commands from those players to the server, resulting in the next state 
\[
		S_{i} = \left\{
			\begin{array}{cl}
				S_0 & : \ i = 0 \\
					\left(\underset{f_p^c\in F}\bigcirc f_p^c\right)(S_{i-1}) & : \ \text{otherwise}
			\end{array}
		\right. %\in \mathcal{S}
\]
%TA BORT \(\mathfrak{U}\)? TRÄNINGENS SUMMERING ÄR FORTFARANDE VETTIG GIVEN EN PROBLEMMÄNGD STÖRRE ÄN 1

where \(S_0\) is the initial configuration of the game field.
%and \(\mathfrak{U}\) is an unknown function representing collision handling and other unknown behaviours of the server simulation and program-server interface (such as the delayed field information). %RANDOMNESS MAKES THE SOLUTION-FINDING MODELING HARDER -- STATISTICS AND SUCH

\subsection{Behaviour tree}
Let \(\phi_\mathfrak{a}\in\Phi\subseteq\mathcal{S}\) be the set of all \textit{preconditional states} of an action \(\mathfrak{a}\in\mathfrak{A}\). A precondition of an action represents some statement about the set of all states \(\mathcal{S}\), such as ``a player cannot kick the ball unless it is near thereto'', or in other words, ``the set of all states where any agent \(p\in\mathcal{P}\) successfully kicks the ball \(\text{Kick}_p \subseteq \mathcal{S}\) is a subset to the set of all states where that player is near it \(\text{NearBall}_p \subseteq \mathcal{S}\), i.e., \(\text{Kick}_p \subseteq \text{NearBall}_p\)''.
%Let \(\pi(\phi)\in\mathfrak{A}\) be the action whose execution is supposed to bring about a set of states. \(\overset{\mathfrak{a}} \Pi : \underset{\Phi_\mathfrak{a}\in\Phi} \bigcup \Phi_\mathfrak{a} \to \mathfrak{A}\).

An action \(\mathfrak{a}\in\mathfrak{A}\) is either a symbol refering to some implemented function inside the program or it is a set of other actions in \(\mathfrak{A}\). \(\overset{\phi}\Pi : \mathfrak{A} \to \Phi\) is a map linking an action to its set of preconditional states. \(\overset{\mathfrak{a}}\Pi : \Phi \to \mathfrak{A}\) is a map linking preconditional states to the action whose execution is supposed to lead thereto.

A node of the behaviour tree is represented as a pair \(\langle \mathfrak{t}, \beta \rangle\) where \(\mathfrak{t}\in\mathfrak{T}\) is the \textit{type} of node -- sequence, selector, condition or action -- and \(\beta\) is a vector (from left to right) of the nodes' children. The function \(\text{BT}:\Phi\cup\mathfrak{A} \to \mathscr{B}\) (where \(\mathscr{B}\) is the set of all behaviour trees) generates the appropriate behaviour tree for an action given its definition and preconditions.

\begin{equation}
		\text{BT}(\omega) := \left\{
			\begin{array}{cl}
					\left\langle \boxed{\to}, \left(\text{BT}\left(\overset{\mathfrak{\phi}} \Pi (\omega)\right), \text{BT}(\omega')\right) \right\rangle \ \text{for any}\  \omega' \in \omega & : \ \text{Set}(\omega') \wedge \omega\in\mathfrak{A} \\
					\left\langle \boxed{?}, \left(\omega,\text{BT}\left(\overset{\mathfrak{a}} \Pi (\omega)\right)\right) \right\rangle & : \ \omega\in\Phi \\
					\left\langle \omega, () \right\rangle & : \ \text{otherwise}
			\end{array}
		\right.
\end{equation}

In this way, if the actions are effective, the behaviour tree will always choose to execute the actions which lead to any of the states in the desired set\footnote{The proof hereof is omitted, but trust me bro.}. The behaviour tree generated by the action ``move ball to location'' is shown in figure XXXXXXXXXX.

\begin{figure}[tbp]
\centering
\begin{forest}
  for tree={draw,
			align=center
		},
		[Ø
			%[\(\to\)
				[?
					[\textit{Ball near}\\\textit{location?}, rounded corners
]
					[\(\to\)
						[?
							[\textit{Player near}\\\textit{ball?}, rounded corners
							]
							[\(\to\)
								[?
									[\textit{Player at}\\\textit{breaking}\\\textit{distance?}, rounded corners
]
									[\(\to\)
										[?
											[\textit{Player facing}\\\textit{target (far)?}, rounded corners
]
											[\texttt{alignFar()}]
										]
										[\texttt{goTowardFar()}]
									]
								]
								[\(\to\)
									[?
										[\textit{Player facing}\\\textit{target (close)?}, rounded corners
]
										[\texttt{alignClose()}]
									]
									[\texttt{goTowardClose()}]
								]
							]
						]
						[\(\to\)
							[?
								[\textit{Player}\\\textit{aligned}\\\textit{to kick?}, rounded corners
]
								[\texttt{alignKick()}]
							]
							[\texttt{kickBall()}]
						]
					]
				]
			%]
		]
\end{forest}
\caption{tree mf}
\label{fig:gene}
\end{figure}
%The structure of the behaviour tree is generated by the following logic: \(\text{Kick ball} \Rightarrow \text{Close to ball} \Rightarrow \text{Go to ball}\), \(\mathscr{K} \subseteq \mathscr{C}\)

\subsection{Genetic algorithm}
Let the monoid \(M^c\) be compositionally generated by the maps \(\mathfrak{A}^c := \bigcup_{f\in\mathcal{A}} \mathfrak{U}\circ f^c\).
\begin{equation}
		M^c:=\left(\langle\mathfrak{A}^c\rangle,\circ\right)
\end{equation}

Let \(\mathscr{S}^c_\mathcal{G}\) be the set of all map-compositions who equal some element in a set \(\mathcal{G}\in M^c\) -- i.e. every \textit{solution} to the problem \(\mathcal{G}\) given the action-space \(\mathfrak{A}^c\).

\begin{equation}
		\mathscr{S}^c_\mathcal{G} = \left\{ s^c \in \bigcup_{n\in \mathbb{N}}\mathfrak{A}^{c^n} \,\middle|\, \mathcal{G}\subseteq M\wedge\overset{1}{\underset{i=|s^c|}\bigcirc} s^c_i \in \mathcal{G} \right\}
\end{equation}

%Let \(\mathscr{B}_\mathcal{G}\subseteq\{\mathscr{S}^c_\mathcal{G} | c\in\mathcal{C}\}\)

The best solutions, then, would be the ones who's 

\begin{equation}
		\mathscr{C} := \left\{ c \in \mathcal{C} \,\middle|\, c'\in\mathcal{C} \Rightarrow \sum_{\mathcal{G}\subseteq M^c} \left|s^{c}\right| \le \sum_{\mathcal{G}\subseteq \underset {S,S'\in\mathcal{S}} \bigcup S\mapsto S'} \left|s^{c'}\right| \right\}
\end{equation}
Avbildningsmängden \(\mathscr{F}_x\) definieras som samtliga \textit{kortaste} lösningar till \(x\).

\begin{equation}
		\mathscr{F}_x=\left\{s\in\mathscr{S}_x \,\middle|\, s'\in \mathscr{S}_x \Rightarrow |s|\le|s'|\right\}
\end{equation}

[ADD INFO ABOUT GA]

\end{document}
